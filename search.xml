<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker介绍</title>
      <link href="/2017/05/25/docker/docker%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/05/25/docker/docker%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h2><p>docker是一个开源的应用容器引擎，让开发者可以打包自己的应用或者依赖到一个可移植的容器中，然后发布到任何流行的linux上。docker完全采用沙箱机制，相互之间不会有任何接口。<a id="more"></a></p><h2 id="docker理解"><a href="#docker理解" class="headerlink" title="docker理解"></a>docker理解</h2><p>标准化：运输方式，API接口，存储方式</p><p>隔离： 通过内核的namespace，包括进程、网络、进程间通信信号、文件系统、用户等，不同的docker使用不同的 namespace</p><pre><code>1、进程的namespace, docker container里运行的进程的父进程是这个docker container的进程。这样不同的    container 之间进程就被隔离开了。2、网络的namespace ,每个container 都有自己的虚拟网络设备，IP地址，路由。3、进程间交互的namespace，每个container 内的进程可以实现进程进的信号、共享内存、消息队列的交互4、mnt的namespace ，不同的namespacer进程看到的文件结构是不同的5、UTS 的namespace ，不同的container 可以有自己的hostname和domainame6、用户的namespae,每个container可以有自己的用户和用户分组    </code></pre><p>集装箱：它可以把任何应用及相关依赖项打包成一个轻量、可移植、自包涵式的容器</p><p>作用：<br>    1，解决运行环境不一致带来的问题。<br>    2，docker的标准化让快速扩展和弹性伸缩变得简单</p><p>镜像的存储格式：linux 分层存储</p><p>容器：其实就是个进程，可以看作一个虚拟机，是可以修改的，而镜像是不可以修改的</p><p>仓库：</p><p>基本命令：</p><ul><li>从远程仓库拉取镜像：docker pull [镜像名称]：[TAG（默认lasted）]</li><li>查看本地镜像：docker image</li><li>后台运行：docker run [options]-d imgage:TAG [command]</li><li>docker ps 查看</li><li>进入一个正在运行的容器：docker exec [options] [imageId] bash</li><li>停止正在运行的容器: docker stop -f [imageId]<br>端口映射：docker run -d -p 主机端口：容器端口 容器id(-P 开放所有端口映射到随机端口)</li></ul><h2 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h2><p>网络类型：</p><pre><code>bridge：桥接Host：云主机共享ip和端口None：docker将不会和外界进行通讯</code></pre><p>使用bridge模式时，通过端口映射将主机端口和容器里的端口做一个映射，容器和主机网卡通过网桥连接</p><p>netstat -na|grep 8080</p><h2 id="第一个自己的镜像"><a href="#第一个自己的镜像" class="headerlink" title="第一个自己的镜像"></a>第一个自己的镜像</h2><p>Dockerfile 创建一个dockerfile</p><p>1，下载一个tomcat镜像，这个镜像已经包含jdk</p><ul><li><p>vi Dockerfile</p></li><li><p>from 镜像名字</p></li><li><p>MAINTAINER username email(镜像的所有者) </p></li><li><p>COPY web应用全路径 /usr/local/tomcat/webapps(应用目录)</p></li></ul><p>2,构建镜像</p><ul><li><p>docker build -t xxx:latest 镜像目录(当前Dockerfie目录用.表示)</p></li><li><p>docker build –help </p></li><li><p>Docker build</p></li></ul><p>3，启动自己镜像</p><p>例如：jpress(web应用)</p>]]></content>
      
      
      <categories>
          
          <category> Docker容器引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty之UDP网络编程</title>
      <link href="/2017/04/27/network/netty%E4%B9%8BUDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/04/27/network/netty%E4%B9%8BUDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP与UDP区别-："><a href="#TCP与UDP区别-：" class="headerlink" title="TCP与UDP区别 ："></a>TCP与UDP区别 ：</h2><ul><li>TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</li><li>UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快</li><li>可以看出，UDP与TCP的主要区别在于：UDP是无连接的，而这一点便是在使用netty进行开发时最重要的区别点了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基本安装</title>
      <link href="/2017/04/27/docker/Docker%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85/"/>
      <url>/2017/04/27/docker/Docker%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="centos-readhat上安装docker"><a href="#centos-readhat上安装docker" class="headerlink" title="centos/readhat上安装docker"></a>centos/readhat上安装docker</h2><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ul><li><p>64-bit 系统</p></li><li><p>kernel 3.8+  <a id="more"></a><br>1，检查linux版本内核：</p><p>uname -r</p></li></ul><p>2，使用sudo 或是 root 权限</p><p>3，确保yum是最新的</p><pre><code>yum update</code></pre><p>4,添加yum仓库：</p><pre><code>tee /etc/yum.repos.d/docker.repo &lt;&lt;-&apos;EOF[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF</code></pre><p>5，安装Docker</p><pre><code>yum install -y docker-engine</code></pre><p>6, 启动Docker</p><pre><code>systemctl start docker.service</code></pre><p>7，查看是否启动成功（client和service两部分表示docker安装启动成功了）,执行命令：</p><pre><code>docker version</code></pre><p>结果：</p><pre><code>Client: Version:      17.04.0-ce API version:  1.28 Go version:   go1.7.5 Git commit:   4845c56 Built:        Mon Apr  3 18:01:50 2017 OS/Arch:      linux/amd64Server: Version:      17.04.0-ce API version:  1.28 (minimum version 1.12) Go version:   go1.7.5 Git commit:   4845c56 Built:        Mon Apr  3 18:01:50 2017 OS/Arch:      linux/amd64 Experimental: false</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker容器引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu16.4基本软件的安装使用</title>
      <link href="/2017/04/27/linux/ubuntu16.4%E5%9F%BA%E6%9C%AC%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/04/27/linux/ubuntu16.4%E5%9F%BA%E6%9C%AC%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="use-root"><a href="#use-root" class="headerlink" title="use root"></a>use root</h2><p>1、Ubuntu的默认root密码是随机的，即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，<br>enter，</p><p>2、终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了 <a id="more"></a></p><h2 id="google-chrome-install"><a href="#google-chrome-install" class="headerlink" title="google chrome install"></a>google chrome install</h2><p>1,exc command:</p><pre><code>sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/</code></pre><p>2,导入谷歌软件的公钥，用于下面步骤中对下载软件进行验证,在终端中，输入以下命令：</p><pre><code>wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -</code></pre><p>3,在终端中，输入以下命令：</p><pre><code>sudo apt-get update</code></pre><p>4,start google-chrome:</p><pre><code>/usr/bin/google-chrome-stable</code></pre><h2 id="fcitx框架下谷歌输入法的安装"><a href="#fcitx框架下谷歌输入法的安装" class="headerlink" title="fcitx框架下谷歌输入法的安装"></a>fcitx框架下谷歌输入法的安装</h2><p>1, 打开终端输入下面的命令:</p><pre><code>sudo apt install fcitx-googlepinyin</code></pre><p>2,在 system setting &gt; Language Support 中 Keyboard input method system 选择 fcitx</p><p>3,restart，输入法设置中找到google-pinyin</p>]]></content>
      
      
      <categories>
          
          <category> linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty基础之TCP粘包拆包问题</title>
      <link href="/2017/04/24/network/netty%E5%9F%BA%E7%A1%80%E4%B9%8BTCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/24/network/netty%E5%9F%BA%E7%A1%80%E4%B9%8BTCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP粘包、拆包问题"><a href="#TCP粘包、拆包问题" class="headerlink" title="TCP粘包、拆包问题"></a>TCP粘包、拆包问题</h2><p>熟悉tcp编程的可能都知道，无论是客户端还是服务器，当我们发送或接收数据时都需要考虑tcp底层的粘包和拆包问题。</p><p>TCP是一个流数据，所谓的“流”就是没有界限的遗传数据，就像水流一样，没有界限。TCP并不了解上层业务数据的具体含义，它会根据tcp缓存区的实际情况进行包的划分，也就是说，在业务上，我们的一个完整的包可能会被tcp分成多个包进行发送，我们的多个小包也可能被封装成一个较大的包进行传输，这就是粘包和拆包问题。</p><ul><li><p>粘包，拆包产生的原因：</p><p>1，应用程序write写入的字节大于套接字发送缓冲区的大小</p><p>2，进行MSS大小的TCP分段</p><p>3，以太网帧的payload大于MTU进行IP分片</p></li></ul><h2 id="TCP粘包，拆包问题的解决方案"><a href="#TCP粘包，拆包问题的解决方案" class="headerlink" title="TCP粘包，拆包问题的解决方案"></a>TCP粘包，拆包问题的解决方案</h2><ul><li><p>根据业界主流协议，有以下几种解决方案：</p><p>1,消息定长，例如每个报文固定大小，如果不够，空位补空格</p><pre><code>FlxedLengthFrameDecoder//设置定长字符串接收socketChannel.pipeline().addLast(new FixedLengthFrameDecoder(6));socketChannel.pipeline().addLast(new StringDecoder());</code></pre><p>2，在包的尾部增加特殊的分割字符，例如回车等</p><pre><code>DelmiterBasedFrameDecoderByteBuf buf = Unpooled.copiedBuffer(&quot;$_&quot;.getBytes());socketChannel.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buf));socketChannel.pipeline().addLast(new StringDecoder());</code></pre><p>3，将消息分为消息头和消息体，在消息头中包含表示消息总长度的字段，然后进行逻辑处理</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IBM人工智能培训酱油记</title>
      <link href="/2017/04/18/categories/live/IBM%E9%85%B1%E6%B2%B9%E8%AE%B0/"/>
      <url>/2017/04/18/categories/live/IBM%E9%85%B1%E6%B2%B9%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="酱油记"><a href="#酱油记" class="headerlink" title="酱油记"></a>酱油记</h2><p>今天去参加IBM参加培训，经历也算是一波三折的。早上老早起来奔袭到南京站，差点没赶上车，不过上海的天气还是不错的，顺便又去东方明珠附近转了转，遇见剧组在那拍电影，感觉自己又做了一回不明觉厉的吃瓜群众。<a id="more"></a>站在高楼林立间，脑海瞬间浮出我站在顶楼拿着咖啡，告诉助理去给我买下这条街，被一个老外过来一个大嘴巴子打醒，“HI Man ,别他么做梦了，回去写程序吧！”。当年杜月笙也是从这里起来的，虽然不敢与杜月笙相提并论，但是眼下这个时代更适合我。</p><p>最可怕的是什么都不知道，当我们对新事物的认知时，感觉一切都是那么有趣，一个worker不管是从事技术，还是从事业务，我觉得我们都需要一直保持求知欲。IBM这个公司对于我一直在小公司干苦力的小朋友来说多少还是存在几分敬畏。今天虽然更多的是关于运维方面的培训，但是干货也不少，感觉培训老师的业务能力还是很强，对F&amp;A,Q&amp;A人工智能还是有了一个比较清晰的认识，也了解了IBM实验室目前对企业在人工智能方面的解决方案和研究成果。作为一个码农，我还侧重关注的是他们人工智能引擎和管理平台的实现，所使用的技术解决方案，时间有限，别人不愿公开ppt和外网访问不到，瞬间觉得我们就变成了酱油瓶，当然，我会在后续的博客中分享今天学到的一些知识，和通过查找资料进行部分代码实现展示出来。</p><p>在参加培训前，我坐在IBM咖啡厅里还心存疑虑，因为我们是代表公司的运维团队去参加的，怕别人高姿态对待，飙英语什么的，公司对今天的内容完全空白，来之前也查了资料，但网上非常少。当然我只是一面之缘，只是在研发中心，只代表个人第一印象。但是去了给人感觉完全不一样，没有多奢华的办公司，听他们开会讨论，分工明确，很接地气，瞬间没了压力，完全是在一个很轻松的环境，大家又讨论的很积极，氛围好，就会让人积极高效的思考，这才是我喜欢这样的团队。总之，心情还是不错的，收获最大的是思维方式的转变，多思考，多总结，多学习。</p><p>唯独不happy的事，还得赶车回南京，呜呜呜。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程---锁</title>
      <link href="/2017/04/17/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B---%E9%94%81/"/>
      <url>/2017/04/17/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B---%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>在Java多线程中，我们可以使用synchronized关键字来实现线程之间的同步互斥工作，jdk中定义了另一种更优秀的完成这个“同步互斥”工作的对象，那就是LOCK，相比synchronized而言，LOCK对象支持嗅探锁定，多路分支的功能。</p><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p><strong>ReentrantLock</strong>:在代码需要同步的地方加上锁定，但是不要忘记最后一定要释放锁，不然会产生死锁，其他线程永远进不来。</p><pre><code>private Lock lock = new ReentrantLock();public void method1(){        try {            lock.lock();            System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;进入method1..&quot;);            Thread.sleep(1000);            System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;退出method1..&quot;);            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }</code></pre><p>参考：<a href="http://blog.csdn.net/fw0124/article/details/6672522" target="_blank" rel="noopener">http://blog.csdn.net/fw0124/article/details/6672522</a></p><h2 id="锁与等待-通知"><a href="#锁与等待-通知" class="headerlink" title="锁与等待/通知"></a>锁与等待/通知</h2><p>在之前我们使用synchronized时，如果需要多线程之间的协作，则需要使用Object的wait(),notify()和notifyAll()方法进行配合工作。</p><p>条件变量Condition,很类似wait，notify（）方法的用法，condition一定是针对某一把锁的。</p><ul><li><p>锁特性：如果是公平锁，线程则按照FIFO顺序从condition.await（）中释放，如果是非公平锁，后序通过竞争就不能保证FIFO的顺序了。</p><pre><code>public ReentrantLock(boolean fair) {   sync = fair ? new FairSync() : new NonfairSync();}</code></pre></li><li><p>我们可以通过一个lock对象，产生多个condition来进行多线程的交互,可以是部分唤醒。</p><pre><code>public class UseManyCondition {private ReentrantLock lock = new ReentrantLock();private Condition c1 = lock.newCondition();private Condition c2 = lock.newCondition();public void m1(){    try {        lock.lock();        System.out.println(&quot;当前线程：&quot; +Thread.currentThread().getName() + &quot;进入方法m1等待..&quot;);        c1.await();        System.out.println(&quot;当前线程：&quot; +Thread.currentThread().getName() + &quot;方法m1继续..&quot;);    } catch (Exception e) {        e.printStackTrace();    } finally {        lock.unlock();    }}public void m2(){    try {        lock.lock();        System.out.println(&quot;当前线程：&quot; +Thread.currentThread().getName() + &quot;进入方法m2等待..&quot;);        c1.await();        System.out.println(&quot;当前线程：&quot; +Thread.currentThread().getName() + &quot;方法m2继续..&quot;);    } catch (Exception e) {        e.printStackTrace();    } finally {        lock.unlock();    }}public void m3(){    try {        lock.lock();        System.out.println(&quot;当前线程：&quot; +Thread.currentThread().getName() + &quot;进入方法m3等待..&quot;);        c2.await();        System.out.println(&quot;当前线程：&quot; +Thread.currentThread().getName() + &quot;方法m3继续..&quot;);    } catch (Exception e) {        e.printStackTrace();    } finally {        lock.unlock();    }}public void m4(){    try {        lock.lock();        System.out.println(&quot;当前线程：&quot; +Thread.currentThread().getName() + &quot;唤醒..&quot;);        c1.signalAll();    } catch (Exception e) {        e.printStackTrace();    } finally {        lock.unlock();    }}public void m5(){    try {        lock.lock();        System.out.println(&quot;当前线程：&quot; +Thread.currentThread().getName() + &quot;唤醒..&quot;);        c2.signal();    } catch (Exception e) {        e.printStackTrace();    } finally {        lock.unlock();    }}public static void main(String[] args) {    final UseManyCondition umc = new UseManyCondition();    Thread t1 = new Thread(new Runnable() {        @Override        public void run() {            umc.m1();        }    },&quot;t1&quot;);    Thread t2 = new Thread(new Runnable() {        @Override        public void run() {            umc.m2();        }    },&quot;t2&quot;);    Thread t3 = new Thread(new Runnable() {        @Override        public void run() {            umc.m3();        }    },&quot;t3&quot;);    Thread t4 = new Thread(new Runnable() {        @Override        public void run() {            umc.m4();        }    },&quot;t4&quot;);    Thread t5 = new Thread(new Runnable() {        @Override        public void run() {            umc.m5();        }    },&quot;t5&quot;);    t1.start();    // c1    t2.start();    // c1    t3.start();    // c2    try {        Thread.sleep(2000);    } catch (InterruptedException e) {        e.printStackTrace();    }    t4.start();    // c1    try {        Thread.sleep(2000);    } catch (InterruptedException e) {        e.printStackTrace();    }    t5.start();    // c2    }}</code></pre></li><li><p>lock.getHoldCount()方法：查询当前线程保持锁的个数(代码略)。</p></li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁ReentrantReadWriteLock,其实就是实现读写分离的锁，在高并发下，尤其是读多写少的情况下性能远高于重入锁。相比sysnchronized和ReentLock，读锁可以在同一时间内被多个线程并发访问。</p><p>其核心思想是：读读共享，写写互斥，读写互斥。</p><pre><code>public class UseReentrantReadWriteLock {private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();private ReadLock readLock = rwLock.readLock();private WriteLock writeLock = rwLock.writeLock();public void read(){    try {        readLock.lock();        System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;进入...&quot;);        Thread.sleep(3000);        System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;退出...&quot;);    } catch (Exception e) {        e.printStackTrace();    } finally {        readLock.unlock();    }}public void write(){    try {        writeLock.lock();        System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;进入...&quot;);        Thread.sleep(3000);        System.out.println(&quot;当前线程:&quot; + Thread.currentThread().getName() + &quot;退出...&quot;);    } catch (Exception e) {        e.printStackTrace();    } finally {        writeLock.unlock();    }}public static void main(String[] args) {    final UseReentrantReadWriteLock urrw = new UseReentrantReadWriteLock();    Thread t1 = new Thread(new Runnable() {        @Override        public void run() {            urrw.read();        }    }, &quot;t1&quot;);    Thread t2 = new Thread(new Runnable() {        @Override        public void run() {            urrw.read();        }    }, &quot;t2&quot;);    Thread t3 = new Thread(new Runnable() {        @Override        public void run() {            urrw.write();        }    }, &quot;t3&quot;);    Thread t4 = new Thread(new Runnable() {        @Override        public void run() {            urrw.write();        }    }, &quot;t4&quot;);        //        t1.start();//        t2.start();//        t1.start(); // R //        t3.start(); // W        t3.start();        t4.start();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty基础之helloworld</title>
      <link href="/2017/04/17/network/netty%E5%9F%BA%E7%A1%80%E4%B9%8Bhelloworld/"/>
      <url>/2017/04/17/network/netty%E5%9F%BA%E7%A1%80%E4%B9%8Bhelloworld/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>现如今我们使用通用的应用程序或者类库来实现系统之间地互相访问，比如我们经常使用一个HTTP客户端来从web服务器上获取信息，或者通过web service来执行一个远程的调用。<a id="more"></a></p><p>然而，有时候一个通用的协议和他的实现并没有覆盖一些场景。比如我们无法使用一个通用的HTTP服务器来处理大文件、电子邮件、近实时消息比如财务信息和多人游戏数据。我们需要一个合适的协议来处理一些特殊的场景。例如你可以实现一个优化的Ajax的聊天应用、媒体流传输或者是大文件传输的HTTP服务器，你甚至可以自己设计和实现一个新的协议来准确地实现你的需求。</p><p>另外不可避免的事情是你不得不处理这些私有协议来确保和原有系统的互通。这个例子将会展示如何快速实现一个不影响应用程序稳定性和性能的协议。</p><p>Netty是一个精心设计的网络通信框架，他吸取了例如FTP，SMTP，HTPP，许多二进制和基于文本的传统协议的很多经验，而且保证了不降低开发效率，稳定性，灵活性，性能。</p><h2 id="Netty引入"><a href="#Netty引入" class="headerlink" title="Netty引入"></a>Netty引入</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Netty是一个提供异步事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络服务器和客户端程序。换句话说，Netty是一个NIO框架，使用它可以简单快速地开发网络应用程序，比如客户端和服务端的协议。Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p><p><img src="http://netty.io/images/components.png" alt="avatar"> </p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>处理器是由Netty生成处理I/O事件，如下实现一个简单的丢弃服务（丢弃服务，指的是会忽略所有接收的数据的一种协议）：</p><pre><code>/** * Created by Larry on 2017/4/23. * ServerChannelHandler */public class DiscardServerHandler extends ChannelHandlerAdapter {    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        try {            // ByteBuf 是一个引用计数对象，用完必须通过显示的调用release()方法进行手动释放。            ByteBuf result = (ByteBuf) msg;            byte[] data = new byte[result.readableBytes()];            // 这个低效的循环事实上可以简化为:System.out.println(result.toString(io.netty.util.CharsetUtil.US_ASCII))            while (result.isReadable()) {                result.readBytes(data);              /*                System.out.print((char) result.readByte());                System.out.flush();*/            }            String request = new String(data, &quot;utf-8&quot;);            System.out.println(&quot;Server:&quot; + request);            // 写给客户端            String response = &quot;Hello,马小琥，服务器收到你的请求，并成功与你建立了连接！&quot;;            /*ctx.write(response) ;            ctx.flush() ;*/            ChannelFuture channelFuture = ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));            // 为此通信管道添加事件监听            channelFuture.addListener(new GenericFutureListener&lt;Future&lt;? super Void&gt;&gt;() {                @Override                public void operationComplete(Future&lt;? super Void&gt; future) throws Exception {                    assert channelFuture == future ;                    channelFuture.channel().close() ;                }            }) ;        } finally {            // 或者，你可以在这里调用in.release()。            ReferenceCountUtil.release(msg);        }    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        cause.printStackTrace();        ctx.close();    }}</code></pre><p>exceptionCaught()事件处理方法是当出现Throwable对象才会被调用，即当Netty由于IO错误或者处理器在处理事件时抛出的异常时。在大部分情况下，捕获的异常应该被记录下来并且把关联的channel给关闭掉。然而这个方法的处理方式会在遇到不同异常的情况下有不同的实现，比如你可能想在关闭连接之前发送一个错误码的响应消息。</p><p>服务器端通过Netty实现：</p><pre><code>public void run() {   // 1,用于接收客户端连接的多线程事件循环器   EventLoopGroup bossGroup = new NioEventLoopGroup();   // 用于处理实际业务操作的多线程事件循环器   EventLoopGroup workerGroup = new NioEventLoopGroup();   try {       // 2,启动NIO服务的辅助启动类       ServerBootstrap sb = new ServerBootstrap();       // 加入工作组       sb.group(bossGroup, workerGroup)               // 3,声明使用NioServerSocketChannel类型的通道               .channel(NioServerSocketChannel.class)               // 4,通过childHandler去绑定具体的事件处理器               .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {                   @Override                   protected void initChannel(SocketChannel socketChannel) throws Exception {                       socketChannel.pipeline().addLast(new DiscardServerHandler());                   }               })               // 5,option（）提供给NioServerSocketChannel用来接收进来的连接               .option(ChannelOption.SO_BACKLOG, 128)               // 6,childOption()是提供给由父管道ServerChannel接收到的连接               .childOption(ChannelOption.SO_KEEPALIVE, true);       // 绑定端口和异步启动接收客户端进来的连接       ChannelFuture cf = sb.bind(port).sync();       // 一直等待，直到服务端socket关闭（在这个例子中，不会发生，但是你可以这样做来优雅的关闭你的服务器）       cf.channel().closeFuture().sync();   } catch (InterruptedException e) {       e.printStackTrace();   } finally {       bossGroup.shutdownGracefully();       workerGroup.shutdownGracefully();   }</code></pre><ul><li>1,NioEventLoopGroup 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的EventLoopGroup的实现用来处理不同传输协议。在这个例子中我们实现了一个服务端的应用，因此会有2个NioEventLoopGroup会被使用。第一个经常被叫做‘boss’，用来接收进来的连接。第二个经常被叫做‘worker’，用来处理已经被接收的连接，一旦‘boss’接收到连接，就会把连接信息注册到‘worker’上。如何知道多少个线程已经被使用，如何映射到已经创建的Channels上都需要依赖于EventLoopGroup的实现，并且可以通过构造函数来配置他们的关系。</li><li>2,ServerBootstrap 是一个启动NIO服务的辅助启动类。你可以在这个服务中直接使用Channel，但是这会是一个复杂的处理过程，在很多情况下你并不需要这样做。</li><li>3,这里我们指定使用NioServerSocketChannel类来举例说明一个新的Channel如何接收进来的连接。</li><li>4,这里的事件处理类经常会被用来处理一个最近的已经接收的Channel。ChannelInitializer是一个特殊的处理类，他的目的是帮助使用者配置一个新的Channel。也许你想通过增加一些处理类比如DiscardServerHandle来配置一个新的Channel或者其对应的ChannelPipeline来实现你的网络程序。当你的程序变的复杂时，可能你会增加更多的处理类到pipline上，然后提取这些匿名类到最顶层的类上。</li><li>5,你可以设置这里指定的通道实现的配置参数。我们正在写一个TCP/IP的服务端，因此我们被允许设置socket的参数选项比如tcpNoDelay和keepAlive。请参考ChannelOption和详细的ChannelConfig实现的接口文档以此可以对ChannelOptions的有一个大概的认识。</li><li>6,你关注过option()和childOption()吗？option()是提供给NioServerSocketChannel用来接收进来的连接。childOption()是提供给由父管道ServerChannel接收到的连接，在这个例子中也是NioServerSocketChannel。<br>我们继续，剩下的就是绑定端口然后启动服务。这里我们在机器上绑定了机器所有网卡上的8080端口。当然现在你可以多次调用bind()方法(基于不同绑定地址)。</li></ul><p>客户端代码和服务器代码相似：</p><pre><code>public void run(){    // 用于处理实际业务操作的多线程事件循环器    EventLoopGroup workerGroup = new NioEventLoopGroup();    try {        // 启动NIO服务的辅助启动类        Bootstrap sb = new Bootstrap();        // 加入工作组        sb.group(workerGroup)                // 声明使用NioServerSocketChannel类型的通道                .channel(NioSocketChannel.class)                // 通过childHandler去绑定具体的事件处理器                .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                    @Override                    protected void initChannel(SocketChannel socketChannel) throws Exception {                        socketChannel.pipeline().addLast(new ClientSocketHandler());                    }                })                // childOption()是提供给由父管道ServerChannel接收到的连接                .option(ChannelOption.SO_KEEPALIVE, true);        // 启动客户端进行服务器连接        ChannelFuture cf = sb.connect(host,port).sync();        // 一直等待，知道连接关闭        cf.channel().closeFuture().sync();    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        workerGroup.shutdownGracefully();    }        }    </code></pre><ul><li>BootStrap和ServerBootstrap类似,不过他是对非服务端的channel而言，比如客户端或者无连接传输模式的 channel。</li><li>如果你只指定了一个EventLoopGroup，那他就会即作为一个‘boss’线程，也会作为一个‘workder’线程，尽管客户* 端不需要使用到‘boss’线程。</li><li>代替NioServerSocketChannel的是NioSocketChannel,这个类在客户端channel被创建时使用。</li><li>不像在使用ServerBootstrap时需要用childOption()方法，因为客户端的SocketChannel没有父channel的概念。</li><li>我们用connect()方法代替了bind()方法。</li></ul><p>参考文章:<a href="http://ifeve.com/netty5-user-guide/" target="_blank" rel="noopener">http://ifeve.com/netty5-user-guide/</a> <a href="https://github.com/netty/netty/issues/2515" target="_blank" rel="noopener">https://github.com/netty/netty/issues/2515</a></p><p>参考代码:<a href="https://github.com/larrychina/skills/tree/master/socket01" target="_blank" rel="noopener">https://github.com/larrychina/skills/tree/master/socket01</a></p>]]></content>
      
      
      <categories>
          
          <category> Java网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 学习笔记</title>
      <link href="/2017/04/17/js/javascript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/04/17/js/javascript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的arguments和this"><a href="#函数的arguments和this" class="headerlink" title="函数的arguments和this"></a>函数的arguments和this</h3><pre><code>arguments是函数对象中的一个隐藏属性，通过这个属性可以获取相应的参数值，这个属性其实就传递过来的参数，它是一个数组。    function say(color){        alert(color) ;   // 结果为1        for(var cl in arguments){            alert(color) ;        } // 结果为1；2；3    }    say(1,2,3) ;    /**     * arguments这个对象中有个方法callee,arguments.callee(参数)可以反向调用     * 比如在递归中可以使用此方法，从而不会导致因函数名改变而发生错误      */当需要创建一个类时，设置该类的属性和方法需要使用this关键字，次用法类似java的this关键字</code></pre><h3 id="函数的属性，call-apply"><a href="#函数的属性，call-apply" class="headerlink" title="函数的属性，call,apply"></a>函数的属性，call,apply</h3><pre><code>函数有两个重要的属性length和prototype:length在函数中的作用是获取参数的个数：    function fn1(){}    function fn2(a){}    function fn3(a,b){}    fn1.length // 0   fn2.length // 1 fn3.length //2call 函数名.call(对象，参数列表) ；apply 函数名.apply(对象，参数数组)</code></pre><h3 id="对象的工厂方式创建和构造函数创建"><a href="#对象的工厂方式创建和构造函数创建" class="headerlink" title="对象的工厂方式创建和构造函数创建"></a>对象的工厂方式创建和构造函数创建</h3><blockquote><p>   通过工厂方式创建对象：</p></blockquote><pre><code>在函数中先创建一个对象，然后为这个对象设置属性和方法，再返回这个对象：function createPerson(name,age){       var obj = new Object() ;       obj.name = name ;       obj.age = age ;       obj.say = function(){           alert(this.name+&quot;:&quot;+this.age) ;       }}var p = createPerson(&quot;zhangsan&quot;,23) ;console.log(typeof p); //始终都是object 无法检测是Person类型（instanceof）</code></pre><blockquote><p>   通过构造函数方式创建对象:</p></blockquote><pre><code>使用构造函数创建对象跟工厂方式类似，它是的函数名就是对象的类名，属性和方法是用this关键字赋值，对象创建使用new关键字：  function Person(name,age){       this.name = name ;       this.age = age ;       this.say = function(){           alert(this.name+&quot;:&quot;+this.age) ;       }  }  var p1 = new Person(&quot;23&quot;,23) ;  var p2 = new Person(&quot;24&quot;,24) ;  alert(p1.say == p2.say) ; // false 由此可见，使用这种方式创建的对象每一个对象里都会存在方法的拷                                 贝，如果对象行为较多的话，消耗的空间就会很大。                                如果把方法设置成全局的行为，则可以被window对象调用，破坏了对象的封装特性，如果全局行为较多的话就会充斥着大量的全局代码，显得开发比较混乱</code></pre><blockquote><p>   js原型对象是一个非常特殊的对象，当一个函数创建后，就会随之产生一个原型对象，当这个函数创建了一个对象，这个对象会指向这个原型对象</p></blockquote><ul><li><p>检测对象是否有prop指向原型:Person.prototype.isPrototypeOf(p) ; // true or false</p><pre><code>// 使用基于原型的创建属性和方法，则为对象专属，window对象不能调用function Person(){}Person.prototype.name = “zhangsan” ;Person.prototype.age = 23 ;Person.prototype.say = function(){alert(this.name + this.age) ;}var Person p = new Person() ;p.say() ; // 正常输出say() ； //报错</code></pre></li><li><p>p.hasOwnProperty(“属性名”)，检测对象有没有自己设置值：</p><pre><code>var p2 = new Person() ;p2.name = &quot;lisi&quot; ;p2.hasOwerProperty(&quot;name&quot;) // true</code></pre></li><li><p>重写原型的方式:</p><pre><code>Person.prototype={    constructor:Person, // 不指定时会指向objcet,因为原型被重写了    name:&apos;&apos;,    age:&apos;&apos;,    say:function(){    }}</code></pre></li></ul><h3 id="js对象继承"><a href="#js对象继承" class="headerlink" title="js对象继承"></a>js对象继承</h3><ul><li><p>基于原型链的方式继承：</p><pre><code>function Parent(){this.pv = &quot;&quot; ;this.name = &quot;larry&quot; ;}Parent.prototype.show = function(){alert(&quot;parents:&quot;this.name) ;}function Child(){this.cv = &quot;&quot; ;}Child.prototype = new Parent() ;Child.prototype.name = “yp” ;var child = new Child() ;child.show() // yp</code></pre></li><li><p>基于构造函数的方式继承：<br>略</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程---Executors</title>
      <link href="/2017/04/14/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B---Executors/"/>
      <url>/2017/04/14/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B---Executors/</url>
      
        <content type="html"><![CDATA[<h2 id="Executors框架"><a href="#Executors框架" class="headerlink" title="Executors框架"></a>Executors框架</h2><p>jdk提供一些线程管理框架，比如Executors,帮助开发人员有效的进行线程的控制，java.concurrent.util包下的工具类是java并发的核心。Executors扮演着线程工程的角色，我们可以通过它创建不同功能的线程池。</p><p>Executors创建线程池方法:</p><p>Executors创建线程池方法:</p><h3 id="Executors-newFixedThreadPool-int-nThreads"><a href="#Executors-newFixedThreadPool-int-nThreads" class="headerlink" title="Executors.newFixedThreadPool(int nThreads) :"></a>Executors.newFixedThreadPool(int nThreads) :</h3><p>创建一个指定大小的线程池，该方法的线程数始终不变，当提交任务时，若线程池中有空闲线程，则立即执行，若没有空闲线程，则缓冲到一个任务队列中(LinkedBlockingQueue)直到线程池中有空闲线程去执行。</p><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}</code></pre><h3 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool():"></a>Executors.newCachedThreadPool():</h3><p>创建一个可根据实际情况调整大小的线程池，放入线程池的任务都会重用或者启动新的线程来执行任务，知道线程数达到最大，keepAliveTime为60，表示线程空闲60秒后可以重用线程池内已经创建的线程。</p><pre><code>public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}</code></pre><h3 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor():"></a>Executors.newSingleThreadExecutor():</h3><p>创建一个只有一个线程的线程池，如空间则执行任务，反之则将任务缓冲到任务队列中。</p><pre><code>public static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog</title>
      <link href="/2017/03/30/categories/live/blog/"/>
      <url>/2017/03/30/categories/live/blog/</url>
      
        <content type="html"><![CDATA[<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><h3 id="苟且"><a href="#苟且" class="headerlink" title="苟且"></a>苟且</h3><p>没有礁石，就没有美丽的浪花；</p><p>没有挫折，就没有壮丽的人生！</p><p>再长的路，一步步也能走完，再短的路，不迈开双脚也无法到达，平凡的脚步也可以走完伟大的行程！</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/03/30/hello-world/"/>
      <url>/2017/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> start </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java网络编程---BIO,NIO,AIO</title>
      <link href="/2017/03/14/network/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B---BIO,NIO,AIO/"/>
      <url>/2017/03/14/network/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B---BIO,NIO,AIO/</url>
      
        <content type="html"><![CDATA[<h2 id="知识扫盲"><a href="#知识扫盲" class="headerlink" title="知识扫盲"></a>知识扫盲</h2><p>OSI模型：开放系统互连参考模型（open systeminterconnection reference model）</p><p>为了解决网络之间的兼容性问题，帮助各个厂商生产出可兼容的网络设备，国际标准化组织ISO于1984年提出了OSI RM，OSI 参考模型很快成为计算机网络通信的基础模型。</p><h2 id="OSI参考模型："><a href="#OSI参考模型：" class="headerlink" title="OSI参考模型："></a>OSI参考模型：</h2><table><thead><tr><th>OSI分层</th><th align="left">OSI七层功能</th></tr></thead><tbody><tr><td>表示层</td><td align="left">处理数据格式，数据加密等</td></tr><tr><td>会话层</td><td align="left">建立，维护和管理会话</td></tr><tr><td>传输层</td><td align="left">建立主机端到端连接</td></tr><tr><td>网络层</td><td align="left">寻址和路由选择</td></tr><tr><td>数据链路层</td><td align="left">提供介质访问，数据链路管理</td></tr><tr><td>物理层</td><td align="left">比特流传输</td></tr></tbody></table><p>由于OSI模型和协议比较复杂，所以并没有得到广泛的应用。<br>而TCP/IP(transfer control protocol/internet protocol,传输控制协议/网际协议)模型因其开放性和易用性在实践中得到了广泛的应用，TCP/IP协议栈也成为互联网的主流协议</p><h2 id="TCP-IP协议栈："><a href="#TCP-IP协议栈：" class="headerlink" title="TCP/IP协议栈："></a>TCP/IP协议栈：</h2><table><thead><tr><th>TCP/IP</th><th align="left">应用描述</th><th align="left">功能</th></tr></thead><tbody><tr><td>应用层</td><td align="left">HTTP、Telnet、FTP、TFTP</td><td align="left">提供应用程序网络接口</td></tr><tr><td>传输层</td><td align="left">TCP/UDP</td><td align="left">建立端到端连接</td></tr><tr><td>网络层</td><td align="left">IP</td><td align="left">选址和路由选者</td></tr><tr><td>数据链路层</td><td align="left">PPP、</td><td align="left">提供介质访问</td></tr></tbody></table><p>TCP的三次握手（建立连接）和四次挥手（断开连接）：</p><blockquote><p>   建立连接(这三个报文段完成TCP连接的建立)：</p><ul><li>1、请求端（通常也称为客户端）发送一个SYN段表示客户期望连接服务器端口，初始序列号为a。</li><li>2、服务器发回序列号为b的SYN段作为响应。同时设置确认序号为客户端的序列号加1（a+1）作为对客户端的SYN报文 的确认。</li><li>3、客户端设置序列号为服务器端的序列号加1（b+1）作为对服务器端SYN报文段的确认。</li></ul></blockquote><blockquote><p>   断开连接(四次交互完成双方向的连接的关闭)：</p><ul><li>1、请求端（通常也称为客户端）想终止连接则发送一个FIN段，序列号设置为a。</li><li>2、服务器回应一个确认序号为客户端的序列号加1（a+1）的ACK确认段，作为对客户端的FIN报文的确认。</li><li>3、服务器端向客户端发送一个FIN终止段（设置序列号为b，确认号为a+1）。</li><li>4、客户端返回一个确认报文（设置序列号为b+1）作为响应。</li></ul></blockquote><p>详细参考：<a href="https://blog.51cto.com/wangdy/1588379" target="_blank" rel="noopener">This link</a></p><h2 id="java-Socket通信"><a href="#java-Socket通信" class="headerlink" title="java Socket通信"></a>java Socket通信</h2><p>Java Socket 可实现客户端–服务器间的双向实时通信。java.net包中定义的两个类socket和ServerSocket，分别用来实现双向连接的client和server端。</p><h3 id="Socket通信实现方法（以下代码是简单的单线程实现）"><a href="#Socket通信实现方法（以下代码是简单的单线程实现）" class="headerlink" title="Socket通信实现方法（以下代码是简单的单线程实现）"></a>Socket通信实现方法（以下代码是简单的单线程实现）</h3><p>服务端代码：</p><pre><code>// server端public static void main(String[] args) {    try {        // 1,创建一个socket，指定绑定端口，并开启监听这个端口        ServerSocket serverSocket = new ServerSocket(port) ;        // 2,调用accept方法，等待客户端连接        Socket socket = serverSocket.accept() ;        // 3,获取输入流，读取客户端信息        // 4，获取输出流，响应客户端信息        new Thread(new ServerHandler(socket)).start();        serverSocket.close();    } catch (IOException e) {        e.printStackTrace();    }}public class ServerHandler implements Runnable {private Socket socket ;public ServerHandler(Socket socket) {    this.socket = socket;}@Overridepublic void run() {    /**    * 代理服务端处理客户端请求的数据    */    try {        // 接收客户端发送的数据        InputStream is = socket.getInputStream() ;        BufferedReader br = new BufferedReader(new InputStreamReader(is) ) ;        String info = null ;        while ((info = br.readLine()) != null){            System.out.println(&quot;客户端发来信息：&quot;+info);        }        // 响应客户端请求        OutputStream os = socket.getOutputStream() ;        PrintWriter pw = new PrintWriter(os) ;        pw.println(&quot;我是小服，收到你的请求，我响应的数据是：你是个逗比，哈哈哈。。。&quot;);        pw.flush();        socket.shutdownOutput();        br.close();        is.close();        pw.close();        os.close();        //socket.close();    } catch (IOException e) {        e.printStackTrace();    } finally {        if(socket != null){            try {               socket.close();            } catch (IOException e) {                e.printStackTrace();            }        }        socket = null ;    }}</code></pre><p>客户端代码实现：</p><pre><code>public static void main(String[] args) {    Socket socket = null ;    try {        // 1、创建客户端Socket，指定服务器地址和端口        socket = new Socket(&quot;127.0.0.1&quot;,port) ;        // 2,获取输出流，向服务端发起信息        OutputStream os = socket.getOutputStream() ;        PrintWriter pw = new PrintWriter(os) ;        pw.println(&quot;你好，我是小客：&quot;+Client.class.getPackage()+Client.class.toString());        pw.flush();        socket.shutdownOutput();        // 3，获取输入流，读取服务端响应信息        InputStream is = socket.getInputStream() ;        BufferedReader br = new BufferedReader(new InputStreamReader(is)) ;        String info  ;        System.out.println(br.readLine());        while ((info = br.readLine())!=null){            System.out.println(&quot;接收到服务器端响应的消息是：&quot;+info);            break;        }        pw.close();        os.close();    } catch (IOException e) {        e.printStackTrace();    } finally {        try {            if(socket != null){                socket.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>以上是一种比较古老的方式，也就是传统的BIO模式，很明显存在的问题是，当客户端数量较多时，随之也会造成服务器压力比较大，自己实现简单的通过伪异步的方式对其进行优化， 就是利用线程池，将任务放入缓冲队列中。</p><pre><code>// server端public static void main(String[] args) {    ServerSocket server = null;    BufferedReader in = null;    PrintWriter out = null;    try {        server = new ServerSocket(PORT);        System.out.println(&quot;server start&quot;);        Socket socket = null;        HandlerExecutorPool executorPool = new HandlerExecutorPool(50, 1000);        while(true){            socket = server.accept();            System.out.println(&quot;server..................&quot;);            executorPool.execute(new ServerHandler(socket));        }    } catch (Exception e) {        e.printStackTrace();    } finally {        if(in != null){            try {                in.close();            } catch (Exception e1) {                e1.printStackTrace();            }        }        if(out != null){            try {                out.close();            } catch (Exception e2) {                e2.printStackTrace();            }        }        if(server != null){            try {                server.close();            } catch (Exception e3) {                e3.printStackTrace();            }        }        server = null;                    }}HandlerExecutorPool.javapublic class HandlerExecutorPool {    private ExecutorService executor;    public HandlerExecutorPool(int maxPoolSize, int queueSize){        this.executor = new ThreadPoolExecutor(                Runtime.getRuntime().availableProcessors(),                maxPoolSize,                 120L,                 TimeUnit.SECONDS,                new ArrayBlockingQueue&lt;Runnable&gt;(queueSize));    }    public void execute(Runnable task){        this.executor.execute(task);    }}</code></pre><h2 id="BIO-NIO-AIO原理分析及代码实现"><a href="#BIO-NIO-AIO原理分析及代码实现" class="headerlink" title="BIO,NIO,AIO原理分析及代码实现"></a>BIO,NIO,AIO原理分析及代码实现</h2><p>先来个例子理解一下概念，以银行取款为例：</p><ul><li><p>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）。</p></li><li><p>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）。</p></li><li><p>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）。</p></li><li><p>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）。</p></li></ul><h3 id="Java对BIO、NIO、AIO的支持："><a href="#Java对BIO、NIO、AIO的支持：" class="headerlink" title="Java对BIO、NIO、AIO的支持："></a>Java对BIO、NIO、AIO的支持：</h3><ul><li><p>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p></li><li><p>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p></li><li><p>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</p></li></ul><p><strong>BIO、NIO、AIO适用场景分析:</strong></p><ul><li><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p></li><li><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p></li><li><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p></li></ul><blockquote><p>   在上面小节已经介绍过BIO这种阻塞通信模型了，存在的明显的问题是：</p></blockquote><pre><code>1，当客户端连接数较多时，服务端就会创建大量的线程，就会造成大量的内存开销和耗时2，频繁的上下文切换而且大多数切换都是无意义的。</code></pre><blockquote><p>   BIO这种阻塞通信模型（引入多路复用器的概念）：</p></blockquote><h3 id="NIO、AIO代码实现"><a href="#NIO、AIO代码实现" class="headerlink" title="NIO、AIO代码实现:"></a>NIO、AIO代码实现:</h3><p><a href="https://github.com/larrychina/skills/tree/master/socket01" target="_blank" rel="noopener">代码示例</a></p>]]></content>
      
      
      <categories>
          
          <category> Java网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
